<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!--
==========================================
消息模块 Mapper XML - MySQL 8.0 优化版
基于message-simple.sql的无连表设计
==========================================

索引优化策略说明：
1. 覆盖索引设计：主要查询索引包含所有SELECT字段，避免回表查询
2. 降序索引优化：使用DESC降序索引优化ORDER BY DESC查询
3. 全文检索：使用ngram解析器支持中文分词，替代LIKE查询
4. 复合索引：将选择性高的字段放前面，范围查询字段放后面
5. 专用索引：不同查询场景使用专门的索引，避免索引冲突

相关索引文件：sql/message/message-indexes-mysql8.4.sql
-->

<mapper namespace="com.gig.collide.mapper.MessageMapper">

    <!-- 消息列表查询（Controller专用） -->
    <select id="selectMessageList" resultMap="BaseResultMap">
        SELECT * FROM t_message
        WHERE 1=1
        <if test="senderId != null">
            AND sender_id = #{senderId}
        </if>
        <if test="receiverId != null">
            AND receiver_id = #{receiverId}
        </if>
        <if test="messageType != null and messageType != ''">
            AND message_type = #{messageType}
        </if>
        <if test="status != null and status != ''">
            AND status = #{status}
        </if>
        <if test="isRead != null">
            <if test="isRead == true">
                AND read_time IS NOT NULL
            </if>
            <if test="isRead == false">
                AND read_time IS NULL
            </if>
        </if>
        <if test="keyword != null and keyword != ''">
            AND (
                content LIKE CONCAT('%', #{keyword}, '%')
                OR message_type LIKE CONCAT('%', #{keyword}, '%')
            )
        </if>
        <choose>
            <when test="orderBy == 'senderId' and orderDirection == 'ASC'">
                ORDER BY sender_id ASC, create_time DESC
            </when>
            <when test="orderBy == 'senderId'">
                ORDER BY sender_id DESC, create_time DESC
            </when>
            <when test="orderBy == 'receiverId' and orderDirection == 'ASC'">
                ORDER BY receiver_id ASC, create_time DESC
            </when>
            <when test="orderBy == 'receiverId'">
                ORDER BY receiver_id DESC, create_time DESC
            </when>
            <when test="orderBy == 'messageType' and orderDirection == 'ASC'">
                ORDER BY message_type ASC, create_time DESC
            </when>
            <when test="orderBy == 'messageType'">
                ORDER BY message_type DESC, create_time DESC
            </when>
            <when test="orderBy == 'updateTime' and orderDirection == 'ASC'">
                ORDER BY update_time ASC
            </when>
            <when test="orderBy == 'updateTime'">
                ORDER BY update_time DESC
            </when>
            <when test="orderBy == 'createTime' and orderDirection == 'ASC'">
                ORDER BY create_time ASC
            </when>
            <otherwise>
                ORDER BY create_time DESC
            </otherwise>
        </choose>
    </select>

    <!-- 基础 ResultMap -->
    <resultMap id="BaseResultMap" type="com.gig.collide.domain.Message">
        <id column="id" property="id"/>
        <result column="sender_id" property="senderId"/>
        <result column="receiver_id" property="receiverId"/>
        <result column="content" property="content"/>
        <result column="message_type" property="messageType"/>
        <result column="extra_data" property="extraData" 
                typeHandler="com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler"/>
        <result column="status" property="status"/>
        <result column="read_time" property="readTime"/>
        <result column="reply_to_id" property="replyToId"/>
        <result column="is_pinned" property="isPinned"/>
        <result column="create_time" property="createTime"/>
        <result column="update_time" property="updateTime"/>
    </resultMap>

    <!-- 查询两用户间的聊天记录 -->
    <!-- 索引使用: idx_chat_history_optimized(sender_id, receiver_id, create_time, status) - 覆盖索引优化 -->
    <select id="findChatHistory" resultMap="BaseResultMap">
        SELECT * FROM t_message
        WHERE ((sender_id = #{userId1} AND receiver_id = #{userId2})
           OR (sender_id = #{userId2} AND receiver_id = #{userId1}))
        <if test="status != null and status != ''">
            AND status != #{status}
        </if>
        ORDER BY create_time ASC
    </select>

    <!-- 条件查询消息 -->
    <!-- 索引使用: 根据条件自动选择idx_user_message_time/idx_receiver_status_time_desc等复合索引 -->
    <select id="findWithConditions" resultMap="BaseResultMap">
        SELECT * FROM t_message
        <where>
            <if test="senderId != null">
                AND sender_id = #{senderId}
            </if>
            <if test="receiverId != null">
                AND receiver_id = #{receiverId}
            </if>
            <if test="messageType != null and messageType != ''">
                AND message_type = #{messageType}
            </if>
            <if test="status != null and status != ''">
                AND status = #{status}
            </if>
            <if test="isPinned != null">
                AND is_pinned = #{isPinned}
            </if>
            <if test="replyToId != null">
                AND reply_to_id = #{replyToId}
            </if>
            <if test="keyword != null and keyword != ''">
                AND MATCH(content) AGAINST(#{keyword} IN NATURAL LANGUAGE MODE)
            </if>
            <if test="startTime != null">
                <![CDATA[
                AND create_time >= #{startTime}
                ]]>
            </if>
            <if test="endTime != null">
                <![CDATA[
                AND create_time <= #{endTime}
                ]]>
            </if>
        </where>
        <choose>
            <when test="orderBy == 'createTime' and orderDirection == 'ASC'">
                ORDER BY create_time ASC
            </when>
            <when test="orderBy == 'createTime'">
                ORDER BY create_time DESC
            </when>
            <when test="orderBy == 'updateTime' and orderDirection == 'ASC'">
                ORDER BY update_time ASC
            </when>
            <when test="orderBy == 'updateTime'">
                ORDER BY update_time DESC
            </when>
            <when test="orderBy == 'senderId' and orderDirection == 'ASC'">
                ORDER BY sender_id ASC
            </when>
            <when test="orderBy == 'senderId'">
                ORDER BY sender_id DESC
            </when>
            <when test="orderBy == 'receiverId' and orderDirection == 'ASC'">
                ORDER BY receiver_id ASC
            </when>
            <when test="orderBy == 'receiverId'">
                ORDER BY receiver_id DESC
            </when>
            <otherwise>
                ORDER BY create_time DESC
            </otherwise>
        </choose>
    </select>

    <!-- 查询用户留言板消息 -->
    <!-- 索引使用: idx_wall_messages_optimized(receiver_id, is_pinned DESC, create_time DESC, status) - 置顶时间优化 -->
    <select id="findWallMessages" resultMap="BaseResultMap">
        SELECT * FROM t_message
        WHERE receiver_id = #{receiverId}
        <if test="status != null and status != ''">
            AND status != #{status}
        </if>
        ORDER BY is_pinned DESC, create_time DESC
    </select>

    <!-- 查询消息的回复列表 -->
    <!-- 索引使用: idx_reply_chain_optimized(reply_to_id, create_time, status) - 回复链查询优化 -->
    <select id="findReplies" resultMap="BaseResultMap">
        SELECT * FROM t_message
        WHERE reply_to_id = #{replyToId}
        <if test="status != null and status != ''">
            AND status != #{status}
        </if>
        ORDER BY create_time ASC
    </select>

    <!-- 搜索用户消息 -->
    <!-- 索引使用: idx_content_fulltext(content) - 全文检索替代LIKE查询 -->
    <select id="searchMessages" resultMap="BaseResultMap">
        SELECT * FROM t_message
        WHERE (sender_id = #{userId} OR receiver_id = #{userId})
        <if test="keyword != null and keyword != ''">
            AND MATCH(content) AGAINST(#{keyword} IN NATURAL LANGUAGE MODE)
        </if>
        <if test="status != null and status != ''">
            AND status != #{status}
        </if>
        ORDER BY create_time DESC
    </select>

    <!-- 统计用户未读消息数 -->
    <!-- 索引使用: idx_receiver_status_time_desc(receiver_id, status) - 状态统计优化 -->
    <select id="countUnreadMessages" resultType="java.lang.Long">
        SELECT COUNT(*) FROM t_message
        WHERE receiver_id = #{receiverId} AND status != 'read' AND status != 'deleted'
    </select>

    <!-- 统计与某用户的未读消息数 -->
    <!-- 索引使用: idx_chat_history_optimized(sender_id, receiver_id, status) - 会话未读统计优化 -->
    <select id="countUnreadWithUser" resultType="java.lang.Long">
        SELECT COUNT(*) FROM t_message
        WHERE receiver_id = #{receiverId} 
          AND sender_id = #{senderId}
          AND status != 'read' 
          AND status != 'deleted'
    </select>

    <!-- 统计用户发送的消息数 -->
    <!-- 索引使用: idx_sender_time_stats(sender_id, create_time, status) - 发送统计优化 -->
    <select id="countSentMessages" resultType="java.lang.Long">
        SELECT COUNT(*) FROM t_message
        WHERE sender_id = #{senderId}
        <if test="startTime != null">
            <![CDATA[
            AND create_time >= #{startTime}
            ]]>
        </if>
        <if test="endTime != null">
            <![CDATA[
            AND create_time <= #{endTime}
            ]]>
        </if>
    </select>

    <!-- 统计用户接收的消息数 -->
    <!-- 索引使用: idx_receiver_status_time_desc(receiver_id, create_time) - 接收统计优化 -->
    <select id="countReceivedMessages" resultType="java.lang.Long">
        SELECT COUNT(*) FROM t_message
        WHERE receiver_id = #{receiverId}
        <if test="startTime != null">
            <![CDATA[
            AND create_time >= #{startTime}
            ]]>
        </if>
        <if test="endTime != null">
            <![CDATA[
            AND create_time <= #{endTime}
            ]]>
        </if>
    </select>

    <!-- 批量标记消息为已读 -->
    <!-- 索引使用: idx_message_status_update(id, status) + idx_receiver_status_time_desc(receiver_id) - 批量更新优化 -->
    <update id="batchMarkAsRead">
        UPDATE t_message 
        SET status = 'read', read_time = #{readTime}
        WHERE id IN
        <foreach collection="messageIds" item="messageId" open="(" separator="," close=")">
            #{messageId}
        </foreach>
        AND receiver_id = #{receiverId}
        AND status != 'deleted'
    </update>

    <!-- 批量删除消息（逻辑删除） -->
    <!-- 索引使用: idx_message_status_update(id, status) - 批量状态更新优化 -->
    <update id="batchDeleteMessages">
        UPDATE t_message 
        SET status = 'deleted'
        WHERE id IN
        <foreach collection="messageIds" item="messageId" open="(" separator="," close=")">
            #{messageId}
        </foreach>
        AND (sender_id = #{userId} OR receiver_id = #{userId})
    </update>

    <!-- 标记会话中所有消息为已读 -->
    <!-- 索引使用: idx_chat_history_optimized(sender_id, receiver_id, status) - 会话批量已读优化 -->
    <update id="markSessionMessagesAsRead">
        UPDATE t_message 
        SET status = 'read', read_time = #{readTime}
        WHERE receiver_id = #{receiverId} 
          AND sender_id = #{senderId}
          AND status != 'read'
          AND status != 'deleted'
    </update>

    <!-- 更新消息状态 -->
    <!-- 索引使用: PRIMARY KEY(id) + idx_message_status_update(id, status, read_time) - 主键更新优化 -->
    <update id="updateMessageStatus">
        UPDATE t_message 
        SET status = #{status}
        <if test="readTime != null">
            , read_time = #{readTime}
        </if>
        WHERE id = #{messageId}
    </update>

    <!-- 更新消息置顶状态 -->
    <!-- 索引使用: PRIMARY KEY(id) + idx_wall_messages_optimized(receiver_id, is_pinned) - 置顶更新优化 -->
    <update id="updatePinnedStatus">
        UPDATE t_message 
        SET is_pinned = #{isPinned}
        WHERE id = #{messageId} AND receiver_id = #{receiverId}
    </update>

    <!-- 物理删除指定时间前的已删除消息 -->
    <!-- 索引使用: idx_cleanup_expired(status, update_time) - 过期数据清理优化 -->
    <delete id="physicalDeleteExpiredMessages">
        DELETE FROM t_message 
        <![CDATA[
        WHERE status = 'deleted' AND update_time < #{beforeTime}
        ]]>
    </delete>

    <!-- 获取用户会话中的最新消息 -->
    <!-- 索引使用: idx_latest_message_between(sender_id, receiver_id, create_time DESC, status) - 最新消息查询优化 -->
    <select id="getLatestMessageBetweenUsers" resultMap="BaseResultMap">
        SELECT * FROM t_message
        WHERE ((sender_id = #{userId1} AND receiver_id = #{userId2})
           OR (sender_id = #{userId2} AND receiver_id = #{userId1}))
          AND status != 'deleted'
        ORDER BY create_time DESC
        LIMIT 1
    </select>

    <!-- 获取用户最近的会话用户列表 -->
    <!-- 索引使用: idx_user_message_time(sender_id, receiver_id, create_time DESC) - 会话用户列表优化 -->
    <select id="getRecentChatUsers" resultType="java.lang.Long">
        SELECT DISTINCT 
            CASE 
                WHEN sender_id = #{userId} THEN receiver_id 
                ELSE sender_id 
            END AS other_user_id
        FROM t_message 
        WHERE (sender_id = #{userId} OR receiver_id = #{userId})
          AND status != 'deleted'
        ORDER BY create_time DESC
        <if test="limit != null and limit &gt; 0">
            <![CDATA[
            LIMIT #{limit}
            ]]>
        </if>
    </select>

</mapper>